import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:music_player/models/song.dart';
import 'package:music_player/services/song_handler.dart';
import 'package:music_player/state/audio_state.dart';
import 'package:on_audio_query/on_audio_query.dart';
import 'package:uuid/uuid.dart';

class DataProcessing {
  static Future<void> fetchLocalStorageToDatabase(
    BuildContext context,
    OnAudioQuery audioQuery,
  ) async {
    debugPrint('Fetching MP3 files from local storage...');
    final songHandler = SongHandler();

    // Request permission to access audio files
    bool permissionStatus = await audioQuery.permissionsStatus();
    if (!permissionStatus) {
      permissionStatus = await audioQuery.permissionsRequest();
    }

    if (!permissionStatus) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Storage permission is required to access music files'),
          duration: Duration(seconds: 2),
          behavior: SnackBarBehavior.floating,
          backgroundColor: Colors.red,
        ),
      );
      return;
    }

    // Query all audio files
    List<SongModel> songs = await audioQuery.querySongs(
      sortType: SongSortType.TITLE,
      uriType: UriType.EXTERNAL,
      ignoreCase: true,
    );
    debugPrint('Total songs fetched: ${songs.length}');

    // Filter songs with duration between 2 to 6 minutes
    final filteredSongs =
        songs.where((song) {
          final durationInSeconds = (song.duration ?? 0) ~/ 1000;
          return durationInSeconds >= 120 && durationInSeconds <= 360;
        }).toList();
    debugPrint('Filtered songs: ${filteredSongs.length}');

    // Map filtered songs to Song objects
    final songsToSave =
        filteredSongs.map((song) {
          return Song(
            id: 0, // Auto-generated by ObjectBox
            uuid: const Uuid().v4(),
            title: cleanTitle(song.title),
            artist: song.artist ?? 'Unknown Artist',
            duration: song.duration ?? 0,
            filePath: song.data,
            vocalPath: "",
            instrumentalPath: "",
            imagePath: "", // Can be updated later
            lyrics: "", // Can be updated later
            amplitude: "",
            timestampLyrics: "",
          );
        }).toList();
    debugPrint('Songs mapped to Song objects.');

    // Save all songs to the database
    songHandler.createSongs(songsToSave);
    debugPrint('Songs saved to database.');
  }

  static Future<void> fetchDatabaseToState(WidgetRef ref) async {
    debugPrint('Fetching songs from database to state...');
    final songHandler = SongHandler();

    // Fetch all songs from the database
    final songs = songHandler.getAllSongs();
    debugPrint('Total songs in database: ${songs.length}');

    // Convert songs to JSON-like format for state
    final displaySongs = songs.map((song) => song.toMap()).toList();
    debugPrint('Songs converted to display format.');

    // Save to Riverpod state using AudioStateNotifier
    ref.read(audioFilesProvider.notifier).state = displaySongs.cast<Song>();
    debugPrint('Songs saved to Riverpod state.');
  }

  static String cleanTitle(String title) {
    // Remove unwanted characters like special symbols
    String cleanedTitle = title.replaceAll(RegExp(r'[^\w\s]'), '');

    // Replace multiple spaces with a single space
    cleanedTitle = cleanedTitle.replaceAll(RegExp(r'\s+'), ' ');

    // Trim leading and trailing whitespace
    cleanedTitle = cleanedTitle.trim();

    // Capitalize the first letter of each word
    cleanedTitle = cleanedTitle
        .split(' ')
        .map(
          (word) =>
              word.isNotEmpty
                  ? word[0].toUpperCase() + word.substring(1).toLowerCase()
                  : '',
        )
        .join(' ');

    return cleanedTitle;
  }
}
